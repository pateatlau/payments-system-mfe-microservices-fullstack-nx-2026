---
alwaysApply: false
---

# Self-Improvement Rules for POC-1

> **Purpose:** Help the AI assistant learn from interactions, improve code quality, and refine patterns over time.

---

## ğŸ¯ Core Principles

1. **Learn from Mistakes** - When errors occur, identify root causes and update patterns
2. **Pattern Recognition** - Recognize successful patterns and reuse them
3. **Continuous Improvement** - Refine code quality, documentation, and practices
4. **Context Awareness** - Adapt to project-specific requirements and constraints
5. **Knowledge Retention** - Remember important decisions and their rationale

---

## ğŸ“š Learning & Pattern Recognition

### Successful Patterns to Recognize

**When a pattern works well, note it:**

- âœ… **Module Federation Setup** - Successful remote configuration patterns
- âœ… **Zustand Store Patterns** - Effective state management structures
- âœ… **TanStack Query Hooks** - Well-structured query/mutation patterns
- âœ… **Form Validation** - Effective React Hook Form + Zod schemas
- âœ… **Route Protection** - Clean ProtectedRoute implementations
- âœ… **TypeScript Patterns** - Type-safe patterns that avoid `any`
- âœ… **Tailwind v4 Usage** - Correct v4 syntax implementations
- âœ… **Test Patterns** - Effective test structures and coverage

### Patterns to Avoid

**When a pattern causes issues, flag it:**

- âŒ **Type Errors** - Patterns that lead to TypeScript errors
- âŒ **Bundling Issues** - Module Federation configuration problems
- âŒ **Test Failures** - Test patterns that are flaky or hard to maintain
- âŒ **Performance Issues** - Code patterns that cause performance problems
- âŒ **Scope Violations** - Code that goes beyond POC-1 scope

---

## ğŸ” Code Quality Improvements

### TypeScript Quality

**Improve type safety:**

- âœ… Prefer `interface` for objects, `type` for unions
- âœ… Avoid `any` - use `unknown` or proper types
- âœ… Use type inference where appropriate
- âœ… Create shared types in `libs/shared-types`
- âœ… Use branded types for IDs when needed

**Example Improvement:**

```typescript
// âŒ BAD
function processData(data: any) { ... }

// âœ… GOOD
function processData<T extends BaseData>(data: T): ProcessedData<T> { ... }
```

### React Component Quality

**Improve component structure:**

- âœ… Single responsibility per component
- âœ… Extract custom hooks for complex logic
- âœ… Use proper prop interfaces
- âœ… Memoize expensive computations
- âœ… Extract constants and types

**Example Improvement:**

```typescript
// âŒ BAD - Mixed concerns
function PaymentForm() {
  const [payments, setPayments] = useState([]);
  const [loading, setLoading] = useState(false);
  // ... form logic mixed with data fetching
}

// âœ… GOOD - Separated concerns
function PaymentForm() {
  const { data: payments, isLoading } = usePayments();
  const { register, handleSubmit } = usePaymentForm();
  // ... clean separation
}
```

### Testing Quality

**Improve test coverage and quality:**

- âœ… Test user interactions, not implementation details
- âœ… Use descriptive test names
- âœ… Test edge cases and error states
- âœ… Mock external dependencies properly
- âœ… Keep tests maintainable and readable

**Example Improvement:**

```typescript
// âŒ BAD - Testing implementation
it('calls setState', () => {
  const setState = jest.fn();
  // ...
});

// âœ… GOOD - Testing behavior
it('displays error message when email is invalid', async () => {
  const user = userEvent.setup();
  render(<SignIn />);
  await user.type(screen.getByLabelText(/email/i), 'invalid');
  await user.click(screen.getByRole('button', { name: /sign in/i }));
  expect(await screen.findByText(/invalid email/i)).toBeInTheDocument();
});
```

---

## ğŸ“– Documentation Improvements

### Code Documentation

**Improve inline documentation:**

- âœ… Document "why" not "what" (code should be self-documenting)
- âœ… Document complex business logic
- âœ… Document security considerations
- âœ… Document stubbed operations (no actual PSP)
- âœ… Document mock authentication patterns

**Example Improvement:**

```typescript
// âŒ BAD - Obvious comment
// Set user to null
setUser(null);

// âœ… GOOD - Explains why
// Clear auth state on logout to prevent unauthorized access
setUser(null);
```

### Architecture Documentation

**Improve architecture docs:**

- âœ… Update implementation plan when patterns change
- âœ… Document decisions and trade-offs
- âœ… Keep task list current
- âœ… Document migration paths
- âœ… Update success criteria as needed

---

## ğŸš€ Performance Optimizations

### React Performance

**Optimize React components:**

- âœ… Use `React.memo` for expensive components
- âœ… Use `useMemo` for expensive computations
- âœ… Use `useCallback` for stable function references
- âœ… Lazy load routes and remotes
- âœ… Optimize re-renders

**Example Improvement:**

```typescript
// âŒ BAD - Unnecessary re-renders
function PaymentList({ payments }) {
  const sorted = payments.sort((a, b) => a.amount - b.amount);
  return <div>{/* ... */}</div>;
}

// âœ… GOOD - Memoized computation
function PaymentList({ payments }) {
  const sorted = useMemo(
    () => [...payments].sort((a, b) => a.amount - b.amount),
    [payments]
  );
  return <div>{/* ... */}</div>;
}
```

### Bundle Size

**Optimize bundle size:**

- âœ… Tree-shake unused code
- âœ… Use dynamic imports for large dependencies
- âœ… Share dependencies via Module Federation
- âœ… Monitor bundle sizes
- âœ… Remove unused dependencies

---

## ğŸ›¡ï¸ Security Improvements

### Security Patterns

**Improve security practices:**

- âœ… Never log sensitive data (passwords, tokens)
- âœ… Validate all inputs with Zod
- âœ… Use secure storage patterns
- âœ… Implement proper error handling (no sensitive data in errors)
- âœ… Follow banking-grade security requirements

**Example Improvement:**

```typescript
// âŒ BAD - Logs sensitive data
console.log('User login:', { email, password });

// âœ… GOOD - No sensitive data logged
console.log('User login attempt:', { email });
```

---

## ğŸ§ª Testing Improvements

### Test Coverage

**Improve test coverage:**

- âœ… Aim for 70%+ coverage
- âœ… Test critical paths first
- âœ… Test error states
- âœ… Test edge cases
- âœ… Test accessibility

### Test Quality

**Improve test maintainability:**

- âœ… Use descriptive test names
- âœ… Keep tests isolated
- âœ… Use proper test data factories
- âœ… Clean up after tests
- âœ… Use appropriate test utilities

---

## ğŸ“‹ Task Management Improvements

### Task Tracking

**Improve task management:**

- âœ… Update task list immediately after completion
- âœ… Mark verification checkboxes
- âœ… Update implementation plan status
- âœ… Document any deviations from plan
- âœ… Ask for confirmation before proceeding

### Communication

**Improve communication:**

- âœ… Provide clear summaries of completed work
- âœ… Explain next steps clearly
- âœ… Ask for confirmation when needed
- âœ… Highlight potential issues early
- âœ… Suggest improvements proactively

---

## ğŸ”„ Refinement Process

### After Each Task

**Review and improve:**

1. âœ… Did the code follow all POC-1 rules?
2. âœ… Are types correct and no `any` used?
3. âœ… Are tests written and passing?
4. âœ… Is documentation updated?
5. âœ… Are there opportunities for improvement?

### After Each Phase

**Reflect and learn:**

1. âœ… What patterns worked well?
2. âœ… What patterns caused issues?
3. âœ… What can be improved for next phase?
4. âœ… Are there reusable patterns to document?
5. âœ… Are there anti-patterns to avoid?

---

## ğŸ’¡ Proactive Improvements

### Suggest Improvements

**When appropriate, suggest:**

- âœ… Code refactoring opportunities
- âœ… Performance optimizations
- âœ… Test coverage improvements
- âœ… Documentation updates
- âœ… Security enhancements
- âœ… Pattern standardization

### Pattern Standardization

**Standardize successful patterns:**

- âœ… Create reusable utilities
- âœ… Extract common patterns to shared libs
- âœ… Document pattern usage
- âœ… Create examples for reference
- âœ… Update project rules if needed

---

## ğŸ“ Knowledge Retention

### Remember Important Decisions

**Track and remember:**

- âœ… Architecture decisions and rationale
- âœ… Technology choices and trade-offs
- âœ… Pattern choices and when to use them
- âœ… Common pitfalls and how to avoid them
- âœ… Project-specific constraints and requirements

### Context Awareness

**Maintain context:**

- âœ… Remember POC-1 scope constraints
- âœ… Remember tech stack versions
- âœ… Remember project structure
- âœ… Remember testing requirements
- âœ… Remember documentation locations

---

## âœ… Success Metrics

### Quality Indicators

**Track improvement:**

- âœ… Reduced TypeScript errors
- âœ… Increased test coverage
- âœ… Faster development cycles
- âœ… Better code reusability
- âœ… Improved documentation quality
- âœ… Fewer bugs and issues
- âœ… Better pattern consistency

---

## ğŸ“ Notes

- These rules are for the AI assistant's self-improvement
- They should be applied contextually, not rigidly
- Focus on practical improvements that benefit the project
- Balance improvement with delivery speed
- Always respect POC-1 scope and constraints

---

**Last Updated:** 2026-01-XX  
**Status:** Active - POC-1 Phase
