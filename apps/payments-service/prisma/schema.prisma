// Payments Service Database Schema
// Database: payments_db (port 5433)
// 
// This schema defines the payment processing data model.
// 
// ZERO COUPLING PATTERN: Payments Service maintains a minimal denormalized User table
// synchronized via RabbitMQ events from Auth Service. This enables recipient validation
// without coupling to Auth Service API.
//
// Event Synchronization Flow:
// 1. Auth Service publishes: auth.user.created, auth.user.updated, auth.user.deleted
// 2. Payments Service subscribes and updates local User table
// 3. Payment creation validates recipients against local User table (no API calls)

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/payments-client"
}

datasource db {
  provider = "postgresql"
  url      = env("PAYMENTS_DATABASE_URL")
}

enum PaymentStatus {
  pending
  processing
  completed
  failed
  cancelled
}

enum PaymentType {
  instant
  scheduled
  recurring
}

// Minimal denormalized User table - synchronized via RabbitMQ events from Auth Service
// Only stores fields needed for payment validation (id, email)
// This enables zero-coupling: Payments Service can validate recipients without calling Auth Service API
model User {
  id    String  @id
  email String  @unique
  // Note: Only minimal fields needed for recipient validation
  // Full user data is in auth_db, this is just for validation

  sentPayments     Payment[] @relation("SentPayments")
  receivedPayments Payment[] @relation("ReceivedPayments")

  @@index([email])
  @@map("users")
}

model Payment {
  id                String        @id @default(uuid())
  senderId          String        @map("sender_id")
  sender            User          @relation("SentPayments", fields: [senderId], references: [id])
  recipientId       String?       @map("recipient_id")
  recipient         User?         @relation("ReceivedPayments", fields: [recipientId], references: [id])
  amount            Decimal       @db.Decimal(10, 2)
  currency          String        @default("USD")
  status            PaymentStatus
  type              PaymentType
  description       String?
  metadata          Json?
  pspTransactionId  String?       @map("psp_transaction_id")
  pspStatus         String?       @map("psp_status")
  failureReason     String?       @map("failure_reason")
  completedAt       DateTime?     @map("completed_at")
  createdAt         DateTime      @default(now()) @map("created_at")
  updatedAt         DateTime      @updatedAt @map("updated_at")

  transactions PaymentTransaction[]

  @@index([senderId])
  @@index([recipientId])
  @@index([status])
  @@index([createdAt])
  @@map("payments")
}

model PaymentTransaction {
  id               String        @id @default(uuid())
  paymentId        String        @map("payment_id")
  status           PaymentStatus
  statusMessage    String?       @map("status_message")
  pspTransactionId String?       @map("psp_transaction_id")
  metadata         Json?
  createdAt        DateTime      @default(now()) @map("created_at")

  payment Payment @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@index([paymentId])
  @@index([createdAt])
  @@map("payment_transactions")
}
